#!/usr/bin/env node

/**
 * USWDS Build Script for EDS Integration
 *
 * This script compiles USWDS components into EDS blocks:
 * 1. Compiles USWDS Sass to CSS for each component
 * 2. Extracts and wraps USWDS JavaScript
 * 3. Copies fonts, icons, and other assets
 * 4. Generates core USWDS styles
 * 5. Creates component documentation
 *
 * Usage:
 *   npm run build:uswds                        # Build all components
 *   npm run build:uswds -- --component=button  # Build single component
 *   npm run build:uswds -- --clean             # Clean and rebuild
 *   npm run build:uswds -- --watch             # Watch for changes
 *   npm run build:uswds -- --force             # Bypass .buildignore protection
 *   npm run build:uswds -- --force --component=card  # Force rebuild single component
 */

const fs = require('fs-extra');
const path = require('path');
const sass = require('sass');
const postcss = require('postcss');
const autoprefixer = require('autoprefixer');
const glob = require('glob');
const { execSync } = require('child_process');

// Load configuration
const config = require('../uswds.config.js');

// Parse command line arguments
const args = process.argv.slice(2);
const options = {
  clean: args.includes('--clean'),
  watch: args.includes('--watch'),
  verbose: args.includes('--verbose') || config.build.verbose,
  component: args.find((arg) => arg.startsWith('--component='))?.split('=')[1],
  minify: args.includes('--minify') || config.build.minify,
  force: args.includes('--force'), // Bypass .buildignore protection
};

// Logging utilities (using ANSI color codes)
const colors = {
  blue: '\x1b[34m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  gray: '\x1b[90m',
  reset: '\x1b[0m',
};

const log = {
  info: (msg) => console.log(`${colors.blue}â„¹${colors.reset}`, msg),
  success: (msg) => console.log(`${colors.green}âœ“${colors.reset}`, msg),
  error: (msg) => console.log(`${colors.red}âœ—${colors.reset}`, msg),
  warn: (msg) => console.log(`${colors.yellow}âš ${colors.reset}`, msg),
  verbose: (msg) => options.verbose && console.log(`${colors.gray}  ${colors.reset}`, msg),
};

/**
 * Main build function
 */
async function build() {
  try {
    log.info('Starting USWDS build process...\n');

    // Clean if requested
    if (options.clean) {
      await cleanOutput();
    }

    // Build core styles
    await buildCore();

    // Build components
    if (options.component) {
      await buildComponent(options.component);
    } else {
      await buildAllComponents();
    }

    // Copy assets
    await copyAssets();

    // Generate documentation
    if (config.build.generateDocs) {
      await generateDocs();
    }

    // Run tests
    if (config.testing.checkBundleSize) {
      await checkBundleSizes();
    }

    // Run linting
    if (config.build.runLinting) {
      await runLinting();
    }

    log.success('\nðŸŽ‰ Build complete!\n');
  } catch (error) {
    log.error(`Build failed: ${error.message}`);
    if (options.verbose) {
      console.error(error);
    }
    process.exit(1);
  }
}

/**
 * Clean output directories
 */
async function cleanOutput() {
  log.info('Cleaning output directories...');

  const dirs = [
    path.join(config.output.styles, 'uswds-*.css'),
    // Don't clean entire blocks dir, just USWDS-generated ones
  ];

  for (const pattern of dirs) {
    const files = glob.sync(pattern);
    for (const file of files) {
      await fs.remove(file);
      log.verbose(`Removed ${file}`);
    }
  }

  log.success('Output directories cleaned');
}

/**
 * Build USWDS core styles
 */
async function buildCore() {
  log.info('Building USWDS core styles...');

  const coreScss = generateCoreScss();
  const outputPath = path.join(config.output.styles, 'uswds-core.css');

  await compileSass(coreScss, outputPath);

  log.success(`Core styles built â†’ ${outputPath}`);
}

/**
 * Generate core Sass content
 */
function generateCoreScss() {
  // USWDS settings using @forward
  const themeSettings = Object.entries(config.theme)
    .map(([key, value]) => {
      // Convert camelCase to kebab-case with proper USWDS naming
      const sassKey = key.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`);
      // Quote string values, leave numbers/bools unquoted
      const sassValue = typeof value === 'string' ? `"${value}"` : value;
      return `$theme-${sassKey}: ${sassValue} !default;`;
    })
    .join('\n');

  return `
// USWDS Core Styles for EDS
// Auto-generated by build-uswds.js

// Set theme settings
${themeSettings}

// Import USWDS
@forward "uswds";
`;
}

/**
 * Build all USWDS components
 */
async function buildAllComponents() {
  log.info(`Building ${Object.keys(config.componentMap).length} components...\n`);

  for (const [uswdsName, blockName] of Object.entries(config.componentMap)) {
    if (config.excludeComponents.includes(uswdsName)) {
      log.verbose(`Skipping ${uswdsName} (excluded)`);
      continue;
    }

    await buildComponent(blockName, uswdsName);
  }

  log.success('All components built');
}

/**
 * Build a single component
 */
async function buildComponent(blockName, uswdsName) {
  // If only blockName provided, find uswdsName
  if (!uswdsName) {
    uswdsName = Object.entries(config.componentMap)
      .find(([, block]) => block === blockName)?.[0];

    if (!uswdsName) {
      throw new Error(`Unknown component: ${blockName}`);
    }
  }

  log.info(`Building ${blockName} (${uswdsName})...`);

  const blockDir = path.join(config.output.blocks, blockName);
  await fs.ensureDir(blockDir);

  // Build CSS
  await buildComponentCSS(uswdsName, blockName, blockDir);

  // Build JavaScript (check .buildignore)
  // EDS Pattern: All block JS files should be custom decorators
  const jsPath = `blocks/${blockName}/${blockName}.js`;
  const buildIgnorePath = path.join(process.cwd(), '.buildignore');
  let skipJS = false;
  if (await fs.pathExists(buildIgnorePath)) {
    const ignoreContent = await fs.readFile(buildIgnorePath, 'utf-8');
    const ignorePatterns = ignoreContent
      .split('\n')
      .map((line) => line.trim())
      .filter((line) => line && !line.startsWith('#'));

    // Support glob patterns like blocks/**/*.js
    skipJS = ignorePatterns.some((pattern) => {
      if (pattern.includes('**')) {
        // Simple glob matching for **
        const regex = new RegExp(pattern.replace(/\*\*/g, '.*').replace(/\*/g, '[^/]*'));
        return regex.test(jsPath);
      }
      return jsPath.includes(pattern);
    });
  }

  if (skipJS && !options.force) {
    log.verbose(`  Skipping ${blockName}.js (protected by .buildignore)`);
  } else {
    if (options.force && skipJS) {
      log.warn(`  Force regenerating ${blockName}.js (overriding .buildignore)`);
    }
    await buildComponentJS(uswdsName, blockName, blockDir);
  }

  // Create README
  if (config.docs.generateBlockReadmes) {
    await buildComponentReadme(uswdsName, blockName, blockDir);
  }

  log.success(`  âœ“ ${blockName}`);
}

/**
 * Build component CSS
 */
async function buildComponentCSS(uswdsName, blockName, blockDir) {
  log.verbose(`  Compiling CSS for ${blockName}...`);

  // Check .buildignore for CSS files (unless --force flag is used)
  const cssPath = `blocks/${blockName}/${blockName}.css`;
  const buildIgnorePath = path.join(process.cwd(), '.buildignore');
  let skipCSS = false;

  if (!options.force && await fs.pathExists(buildIgnorePath)) {
    const ignoreContent = await fs.readFile(buildIgnorePath, 'utf-8');
    const ignorePatterns = ignoreContent
      .split('\n')
      .map((line) => line.trim())
      .filter((line) => line && !line.startsWith('#'));

    // Support glob patterns like blocks/**/*.css
    skipCSS = ignorePatterns.some((pattern) => {
      if (pattern.includes('**')) {
        // Simple glob matching for **
        const regex = new RegExp(pattern.replace(/\*\*/g, '.*').replace(/\*/g, '[^/]*'));
        return regex.test(cssPath);
      }
      return cssPath.includes(pattern);
    });
  }

  if (skipCSS) {
    log.verbose(`  Skipping ${blockName}.css (protected by .buildignore)`);
    return;
  }

  if (options.force && await fs.pathExists(path.join(blockDir, `${blockName}.css`))) {
    log.warn(`  Force regenerating ${blockName}.css (overriding .buildignore)`);
  }

  // Generate component Sass
  const componentScss = `
// ${blockName} component styles
// Compiled from USWDS ${uswdsName}
// Auto-generated by build-uswds.js

@use "${uswdsName}" as *;

// Ensure component styles are scoped to .${blockName} block
.${blockName} {
  // Component content will inherit USWDS styles
  // Additional EDS-specific overrides can go here
}
`;

  const outputPath = path.join(blockDir, `${blockName}.css`);
  await compileSass(componentScss, outputPath);

  log.verbose(`  CSS compiled â†’ ${outputPath}`);
}

/**
 * Build component JavaScript
 */
async function buildComponentJS(uswdsName, blockName, blockDir) {
  log.verbose(`  Creating JavaScript for ${blockName}...`);

  // Check if USWDS component has JavaScript
  const uswdsJsPath = path.join(
    config.uswds.packagesPath,
    uswdsName,
    'src',
    'index.js',
  );

  const hasJS = await fs.pathExists(uswdsJsPath);

  // Generate JavaScript wrapper
  const componentJs = hasJS
    ? generateComponentJSWithUSWDS(uswdsName, blockName)
    : generateComponentJSBasic(blockName);

  const outputPath = path.join(blockDir, `${blockName}.js`);
  await fs.writeFile(outputPath, componentJs);

  log.verbose(`  JavaScript created â†’ ${outputPath}`);
}

/**
 * Generate JavaScript for component with USWDS JS
 */
function generateComponentJSWithUSWDS(uswdsName, blockName) {
  return `/**
 * ${blockName} block
 * Based on USWDS ${uswdsName} component (CSS-only)
 *
 * @see https://designsystem.digital.gov/components/${uswdsName.replace('usa-', '')}/
 */

export default function decorate() {
  // USWDS ${uswdsName} uses CSS for styling
  // JavaScript interactions can be added here as needed for EDS
}
`;
}

/**
 * Generate basic JavaScript for component without USWDS JS
 */
function generateComponentJSBasic(blockName) {
  return `/**
 * ${blockName} block
 *
 * This component does not require JavaScript initialization.
 */

export default function decorate() {
  // Component is styled with CSS only
  // Add any EDS-specific enhancements here if needed
}
`;
}

/**
 * Build component README
 */
async function buildComponentReadme(uswdsName, blockName, blockDir) {
  const uswdsComponentName = uswdsName.replace('usa-', '');
  const uswdsUrl = `https://designsystem.digital.gov/components/${uswdsComponentName}/`;

  const readme = `# ${titleCase(blockName)} Block

This block implements the [USWDS ${titleCase(uswdsComponentName)} component](${uswdsUrl}).

## Usage

In your document, create a table with the class \`${blockName}\`:

\`\`\`
| ${blockName} |
|---|
| Content here |
\`\`\`

## Variants

${config.docs.includeUswdsLinks ? `
See the [USWDS documentation](${uswdsUrl}) for available variants and options.
` : ''}

## Accessibility

This component follows USWDS accessibility guidelines and is WCAG 2.1 AA compliant.

## Development

- **CSS**: Compiled from USWDS Sass (\`${uswdsName}\`)
- **JS**: ${await hasComponentJS(uswdsName) ? `Uses USWDS \`${uswdsName}\` module` : 'CSS only, no JavaScript required'}

## Related

- [USWDS ${titleCase(uswdsComponentName)}](${uswdsUrl})
- [USWDS Design Tokens](https://designsystem.digital.gov/design-tokens/)

---

*This file was auto-generated by \`build-uswds.js\`. Manual edits may be overwritten.*
`;

  const outputPath = path.join(blockDir, 'README.md');
  await fs.writeFile(outputPath, readme);

  log.verbose(`  README created â†’ ${outputPath}`);
}

/**
 * Check if component has JavaScript
 */
async function hasComponentJS(uswdsName) {
  const jsPath = path.join(
    config.uswds.packagesPath,
    uswdsName,
    'src',
    'index.js',
  );
  return fs.pathExists(jsPath);
}

/**
 * Compile Sass to CSS
 */
async function compileSass(sassContent, outputPath) {
  try {
    // Compile Sass
    const result = sass.compileString(sassContent, {
      loadPaths: config.sass.includePaths,
      style: config.sass.outputStyle,
      sourceMap: config.build.sourceMaps,
    });

    // Post-process with autoprefixer and URL rewriting
    const processed = await postcss([
      autoprefixer(config.postcss.autoprefixer),
      // Rewrite relative URLs to absolute paths
      {
        postcssPlugin: 'rewrite-urls',
        Once(root) {
          root.walkDecls((decl) => {
            if (decl.value.includes('url(')) {
              // Rewrite ../fonts/ to /fonts/ (preserve proper quote syntax)
              decl.value = decl.value.replace(
                /url\(["']?\.\.\/fonts\/([^)"']+)(["']?)\)/g,
                (match, filepath) => `url("/fonts/${filepath}")`,
              );
              // Rewrite ../img/ to /icons/ (preserve proper quote syntax)
              decl.value = decl.value.replace(
                /url\(["']?\.\.\/img\/([^)"']+)(["']?)\)/g,
                (match, filepath) => `url("/icons/${filepath}")`,
              );
            }
          });
        },
      },
    ]).process(result.css, {
      from: undefined,
      to: outputPath,
    });

    // Write CSS file
    await fs.writeFile(outputPath, processed.css);

    // Write source map if enabled
    if (config.build.sourceMaps && result.sourceMap) {
      await fs.writeFile(`${outputPath}.map`, JSON.stringify(result.sourceMap));
    }
  } catch (error) {
    throw new Error(`Sass compilation failed: ${error.message}`);
  }
}

/**
 * Copy USWDS assets (fonts, icons, images)
 */
async function copyAssets() {
  log.info('Copying USWDS assets...');

  await copyFonts();
  await copyIcons();
  await copyImages();
  await copyJavaScript();

  log.success('Assets copied');
}

/**
 * Copy USWDS fonts
 */
async function copyFonts() {
  log.verbose('  Copying fonts...');

  const uswdsFontsPath = path.join(config.uswds.packagePath, 'dist', 'fonts');
  const outputFontsPath = config.output.fonts;

  for (const family of config.assets.fonts.families) {
    const srcPath = path.join(uswdsFontsPath, family);
    const destPath = path.join(outputFontsPath, family);

    if (await fs.pathExists(srcPath)) {
      await fs.copy(srcPath, destPath, {
        filter: (src) => {
          // Only copy specified formats
          const ext = path.extname(src).slice(1);
          return !ext || config.assets.fonts.formats.includes(ext);
        },
      });
      log.verbose(`    Copied ${family}`);
    }
  }
}

/**
 * Copy USWDS icons
 */
async function copyIcons() {
  log.verbose('  Copying icons...');

  const uswdsImgPath = path.join(config.uswds.packagePath, 'dist', 'img');
  const outputIconsPath = config.output.icons;

  if (config.assets.icons.copyAll) {
    // Copy all icon directories
    for (const iconSet of config.assets.icons.sets) {
      const srcPath = path.join(uswdsImgPath, iconSet);
      const destPath = path.join(outputIconsPath, iconSet);

      if (await fs.pathExists(srcPath)) {
        await fs.copy(srcPath, destPath);
        log.verbose(`    Copied ${iconSet}`);
      }
    }

    // Copy sprite
    if (config.assets.icons.generateSprite) {
      const spriteSrc = path.join(uswdsImgPath, 'sprite.svg');
      const spriteDest = path.join(outputIconsPath, 'sprite.svg');

      if (await fs.pathExists(spriteSrc)) {
        await fs.copy(spriteSrc, spriteDest);
        log.verbose('    Copied sprite.svg');
      }
    }

    // Copy banner-specific assets
    const bannerAssets = [
      'us_flag_small.png',
      'icon-dot-gov.svg',
      'icon-https.svg',
    ];

    for (const asset of bannerAssets) {
      const assetSrc = path.join(uswdsImgPath, asset);
      const assetDest = path.join(outputIconsPath, asset);

      if (await fs.pathExists(assetSrc)) {
        await fs.copy(assetSrc, assetDest);
        log.verbose(`    Copied banner asset: ${asset}`);
      }
    }
  }
}

/**
 * Copy USWDS images
 */
async function copyImages() {
  if (!config.assets.images.copy) {
    return;
  }

  log.verbose('  Copying images...');

  const uswdsImgPath = path.join(config.uswds.packagePath, 'dist', 'img');
  const outputImagesPath = config.output.images;

  // Copy non-icon images
  const images = await fs.readdir(uswdsImgPath);

  for (const image of images) {
    const srcPath = path.join(uswdsImgPath, image);
    const stat = await fs.stat(srcPath);

    // Skip icon directories
    if (stat.isDirectory() && config.assets.icons.sets.includes(image)) {
      continue;
    }

    // Skip sprite
    if (image === 'sprite.svg') {
      continue;
    }

    const destPath = path.join(outputImagesPath, image);
    await fs.copy(srcPath, destPath);
    log.verbose(`    Copied ${image}`);
  }
}

/**
 * Copy USWDS JavaScript files
 */
async function copyJavaScript() {
  log.verbose('  Copying JavaScript files...');

  const uswdsJsPath = path.join(config.uswds.packagePath, 'dist', 'js');
  const outputJsPath = './libs/uswds';

  await fs.ensureDir(outputJsPath);
  await fs.copy(uswdsJsPath, outputJsPath);

  log.verbose('    Copied USWDS JavaScript modules');
}

/**
 * Generate documentation
 */
async function generateDocs() {
  log.info('Generating documentation...');

  // TODO: Generate comprehensive documentation
  // - Component inventory
  // - Usage examples
  // - Migration guide

  log.success('Documentation generated');
}

/**
 * Check bundle sizes
 */
async function checkBundleSizes() {
  log.info('Checking bundle sizes...');

  // Check core CSS
  const coreCssPath = path.join(config.output.styles, 'uswds-core.css');
  const coreSize = (await fs.stat(coreCssPath)).size;

  if (coreSize > config.testing.maxBundleSize.core) {
    log.warn(`Core CSS (${formatBytes(coreSize)}) exceeds recommended size (${formatBytes(config.testing.maxBundleSize.core)})`);
  } else {
    log.success(`Core CSS: ${formatBytes(coreSize)}`);
  }

  // Check block CSS sizes
  const blocks = await fs.readdir(config.output.blocks);

  for (const block of blocks) {
    const cssPath = path.join(config.output.blocks, block, `${block}.css`);

    if (await fs.pathExists(cssPath)) {
      const { size } = await fs.stat(cssPath);

      if (size > config.testing.maxBundleSize.block) {
        log.warn(`${block}.css (${formatBytes(size)}) exceeds recommended size (${formatBytes(config.testing.maxBundleSize.block)})`);
      }
    }
  }
}

/**
 * Run linting on generated files
 */
async function runLinting() {
  log.info('Running linters on generated files...');

  const lintErrors = {
    js: [],
    css: [],
  };

  // Lint JavaScript files
  try {
    log.verbose('  Linting JavaScript files...');
    execSync('npm run lint:js -- blocks/', {
      stdio: options.verbose ? 'inherit' : 'pipe',
      encoding: 'utf-8',
    });
    log.success('JavaScript files: No lint errors');
  } catch (error) {
    if (error.stdout) {
      lintErrors.js = parseESLintOutput(error.stdout);
      log.warn(`JavaScript files: ${lintErrors.js.length} lint error(s) found`);
      if (options.verbose) {
        lintErrors.js.slice(0, 5).forEach((err) => {
          log.verbose(`  ${err.file}: ${err.message}`);
        });
        if (lintErrors.js.length > 5) {
          log.verbose(`  ... and ${lintErrors.js.length - 5} more`);
        }
      }
    }
  }

  // Lint CSS files
  try {
    log.verbose('  Linting CSS files...');
    execSync('npm run lint:css -- blocks/**/*.css styles/uswds-core.css', {
      stdio: options.verbose ? 'inherit' : 'pipe',
      encoding: 'utf-8',
    });
    log.success('CSS files: No lint errors');
  } catch (error) {
    if (error.stdout) {
      lintErrors.css = parseStylelintOutput(error.stdout);
      log.warn(`CSS files: ${lintErrors.css.length} lint error(s) found`);
      if (options.verbose) {
        lintErrors.css.slice(0, 5).forEach((err) => {
          log.verbose(`  ${err.file}: ${err.message}`);
        });
        if (lintErrors.css.length > 5) {
          log.verbose(`  ... and ${lintErrors.css.length - 5} more`);
        }
      }
    }
  }

  // Write lint report if errors found
  if (lintErrors.js.length > 0 || lintErrors.css.length > 0) {
    await writeLintReport(lintErrors);
    log.info('Lint report saved to LINT-REPORT.md');
  }

  return lintErrors;
}

/**
 * Parse ESLint output
 */
function parseESLintOutput(output) {
  const errors = [];
  const lines = output.split('\n');
  let currentFile = null;

  for (const line of lines) {
    // Match file path line
    if (line.startsWith('/')) {
      currentFile = line.trim();
    } else if (currentFile && /^\s+\d+:\d+\s+(error|warning)/.test(line)) {
      // Match error line (e.g., "  4:3   error  Trailing spaces not allowed")
      const match = line.match(/^\s+(\d+:\d+)\s+(error|warning)\s+(.+?)(?:\s{2,}(.+))?$/);
      if (match) {
        errors.push({
          file: currentFile,
          location: match[1],
          severity: match[2],
          message: match[3].trim(),
          rule: match[4] ? match[4].trim() : '',
        });
      }
    }
  }

  return errors;
}

/**
 * Parse Stylelint output
 */
function parseStylelintOutput(output) {
  const errors = [];
  const lines = output.split('\n');
  let currentFile = null;

  for (const line of lines) {
    // Match file path line
    if (line.match(/^[a-z]/i) && line.includes('.css')) {
      currentFile = line.trim();
    } else if (currentFile && line.includes('âœ–')) {
      // Match error line (e.g., "   17:1    âœ–  Expected empty line before comment")
      const match = line.match(/^\s+(\d+:\d+)\s+âœ–\s+(.+?)(?:\s{2,}(.+))?$/);
      if (match) {
        errors.push({
          file: currentFile,
          location: match[1],
          severity: 'error',
          message: match[2].trim(),
          rule: match[3] ? match[3].trim() : '',
        });
      }
    }
  }

  return errors;
}

/**
 * Write lint report to file
 */
async function writeLintReport(lintErrors) {
  const report = `# Lint Report

Generated: ${new Date().toISOString()}

## Summary

- **JavaScript Errors**: ${lintErrors.js.length}
- **CSS Errors**: ${lintErrors.css.length}
- **Total**: ${lintErrors.js.length + lintErrors.css.length}

${lintErrors.js.length > 0 ? `
## JavaScript Errors

${lintErrors.js.map((err) => `
### ${err.file}

**Location**: Line ${err.location}  
**Severity**: ${err.severity}  
**Rule**: ${err.rule}  
**Message**: ${err.message}
`).join('\n')}
` : ''}

${lintErrors.css.length > 0 ? `
## CSS Errors

${lintErrors.css.map((err) => `
### ${err.file}

**Location**: Line ${err.location}  
**Rule**: ${err.rule}  
**Message**: ${err.message}
`).join('\n')}
` : ''}

## Resolution

Review the errors above and:

1. **Fixable errors**: Update the build script to generate compliant code
2. **USWDS-specific patterns**: Document as unavoidable and update lint config
3. **Configuration issues**: Adjust ESLint/Stylelint rules

---

*Generated by build-uswds.js*
`;

  await fs.writeFile('LINT-REPORT.md', report);
}

/**
 * Utility: Convert to Title Case
 */
function titleCase(str) {
  return str
    .split('-')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

/**
 * Utility: Format bytes to human readable
 */
function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${Math.round((bytes / (k ** i)) * 100) / 100} ${sizes[i]}`;
}

/**
 * Watch mode
 */
async function watch() {
  log.info('Watching for changes...');
  // TODO: Implement file watching
  // Watch USWDS source files and config
  // Rebuild on changes
}

// Run build
if (options.watch) {
  watch();
} else {
  build();
}
