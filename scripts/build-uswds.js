#!/usr/bin/env node

/**
 * USWDS Build Script for EDS Integration
 * 
 * This script compiles USWDS components into EDS blocks:
 * 1. Compiles USWDS Sass to CSS for each component
 * 2. Extracts and wraps USWDS JavaScript
 * 3. Copies fonts, icons, and other assets
 * 4. Generates core USWDS styles
 * 5. Creates component documentation
 * 
 * Usage:
 *   npm run build:uswds                  # Build all components
 *   npm run build:uswds -- --component=button  # Build single component
 *   npm run build:uswds -- --clean      # Clean and rebuild
 *   npm run build:uswds -- --watch      # Watch for changes
 */

const fs = require('fs-extra');
const path = require('path');
const sass = require('sass');
const postcss = require('postcss');
const autoprefixer = require('autoprefixer');
const glob = require('glob');
const chalk = require('chalk');

// Load configuration
const config = require('../uswds.config.js');

// Parse command line arguments
const args = process.argv.slice(2);
const options = {
  clean: args.includes('--clean'),
  watch: args.includes('--watch'),
  verbose: args.includes('--verbose') || config.build.verbose,
  component: args.find(arg => arg.startsWith('--component='))?.split('=')[1],
  minify: args.includes('--minify') || config.build.minify,
};

// Logging utilities
const log = {
  info: (msg) => console.log(chalk.blue('â„¹'), msg),
  success: (msg) => console.log(chalk.green('âœ“'), msg),
  error: (msg) => console.log(chalk.red('âœ—'), msg),
  warn: (msg) => console.log(chalk.yellow('âš '), msg),
  verbose: (msg) => options.verbose && console.log(chalk.gray('  '), msg),
};

/**
 * Main build function
 */
async function build() {
  try {
    log.info('Starting USWDS build process...\n');

    // Clean if requested
    if (options.clean) {
      await cleanOutput();
    }

    // Build core styles
    await buildCore();

    // Build components
    if (options.component) {
      await buildComponent(options.component);
    } else {
      await buildAllComponents();
    }

    // Copy assets
    await copyAssets();

    // Generate documentation
    if (config.build.generateDocs) {
      await generateDocs();
    }

    // Run tests
    if (config.testing.checkBundleSize) {
      await checkBundleSizes();
    }

    log.success('\nðŸŽ‰ Build complete!\n');

  } catch (error) {
    log.error(`Build failed: ${error.message}`);
    if (options.verbose) {
      console.error(error);
    }
    process.exit(1);
  }
}

/**
 * Clean output directories
 */
async function cleanOutput() {
  log.info('Cleaning output directories...');

  const dirs = [
    path.join(config.output.styles, 'uswds-*.css'),
    // Don't clean entire blocks dir, just USWDS-generated ones
  ];

  for (const pattern of dirs) {
    const files = glob.sync(pattern);
    for (const file of files) {
      await fs.remove(file);
      log.verbose(`Removed ${file}`);
    }
  }

  log.success('Output directories cleaned');
}

/**
 * Build USWDS core styles
 */
async function buildCore() {
  log.info('Building USWDS core styles...');

  const coreScss = generateCoreScss();
  const outputPath = path.join(config.output.styles, 'uswds-core.css');

  await compileSass(coreScss, outputPath);

  log.success(`Core styles built â†’ ${outputPath}`);
}

/**
 * Generate core Sass content
 */
function generateCoreScss() {
  const themeSettings = Object.entries(config.theme)
    .map(([key, value]) => {
      // Convert camelCase to kebab-case
      const sassKey = key.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);
      // Quote string values
      const sassValue = typeof value === 'string' ? `"${value}"` : value;
      return `  $theme-${sassKey}: ${sassValue},`;
    })
    .join('\n');

  return `
// USWDS Core Styles for EDS
// Auto-generated by build-uswds.js

@use "uswds-core" with (
${themeSettings}
);

// Include core features
${config.core.include.map(feature => `@include uswds-core.${feature};`).join('\n')}

// Include utilities
${generateUtilitiesInclude()}
`;
}

/**
 * Generate utilities include statements
 */
function generateUtilitiesInclude() {
  if (config.core.utilities.includeAll) {
    return '@include uswds-core.utilities;';
  }

  return config.core.utilities.include
    .map(util => `@include uswds-core.utility-${util};`)
    .join('\n');
}

/**
 * Build all USWDS components
 */
async function buildAllComponents() {
  log.info(`Building ${Object.keys(config.componentMap).length} components...\n`);

  for (const [uswdsName, blockName] of Object.entries(config.componentMap)) {
    if (config.excludeComponents.includes(uswdsName)) {
      log.verbose(`Skipping ${uswdsName} (excluded)`);
      continue;
    }

    await buildComponent(blockName, uswdsName);
  }

  log.success('All components built');
}

/**
 * Build a single component
 */
async function buildComponent(blockName, uswdsName) {
  // If only blockName provided, find uswdsName
  if (!uswdsName) {
    uswdsName = Object.entries(config.componentMap)
      .find(([, block]) => block === blockName)?.[0];
    
    if (!uswdsName) {
      throw new Error(`Unknown component: ${blockName}`);
    }
  }

  log.info(`Building ${blockName} (${uswdsName})...`);

  const blockDir = path.join(config.output.blocks, blockName);
  await fs.ensureDir(blockDir);

  // Build CSS
  await buildComponentCSS(uswdsName, blockName, blockDir);

  // Build JavaScript
  await buildComponentJS(uswdsName, blockName, blockDir);

  // Create README
  if (config.docs.generateBlockReadmes) {
    await buildComponentReadme(uswdsName, blockName, blockDir);
  }

  log.success(`  âœ“ ${blockName}`);
}

/**
 * Build component CSS
 */
async function buildComponentCSS(uswdsName, blockName, blockDir) {
  log.verbose(`  Compiling CSS for ${blockName}...`);

  // Generate component Sass
  const componentScss = `
// ${blockName} component styles
// Compiled from USWDS ${uswdsName}
// Auto-generated by build-uswds.js

@use "${uswdsName}" as *;

// Ensure component styles are scoped to .${blockName} block
.${blockName} {
  // Component content will inherit USWDS styles
  // Additional EDS-specific overrides can go here
}
`;

  const outputPath = path.join(blockDir, `${blockName}.css`);
  await compileSass(componentScss, outputPath);

  log.verbose(`  CSS compiled â†’ ${outputPath}`);
}

/**
 * Build component JavaScript
 */
async function buildComponentJS(uswdsName, blockName, blockDir) {
  log.verbose(`  Creating JavaScript for ${blockName}...`);

  // Check if USWDS component has JavaScript
  const uswdsJsPath = path.join(
    config.uswds.packagesPath,
    uswdsName,
    'src',
    'index.js'
  );

  const hasJS = await fs.pathExists(uswdsJsPath);

  // Generate JavaScript wrapper
  const componentJs = hasJS 
    ? generateComponentJSWithUSWDS(uswdsName, blockName)
    : generateComponentJSBasic(blockName);

  const outputPath = path.join(blockDir, `${blockName}.js`);
  await fs.writeFile(outputPath, componentJs);

  log.verbose(`  JavaScript created â†’ ${outputPath}`);
}

/**
 * Generate JavaScript for component with USWDS JS
 */
function generateComponentJSWithUSWDS(uswdsName, blockName) {
  return `/**
 * ${blockName} block
 * Based on USWDS ${uswdsName} component
 * 
 * @see https://designsystem.digital.gov/components/${uswdsName.replace('usa-', '')}/
 */

import ${camelCase(uswdsName)} from '@uswds/uswds/js/${uswdsName}';

export default function decorate(block) {
  // Initialize USWDS component
  ${camelCase(uswdsName)}.on(block);
  
  // Optional: Add EDS-specific enhancements here
  
  // Return cleanup function
  return () => {
    ${camelCase(uswdsName)}.off(block);
  };
}
`;
}

/**
 * Generate basic JavaScript for component without USWDS JS
 */
function generateComponentJSBasic(blockName) {
  return `/**
 * ${blockName} block
 * 
 * This component does not require JavaScript initialization.
 */

export default function decorate(block) {
  // Component is styled with CSS only
  // Add any EDS-specific enhancements here if needed
}
`;
}

/**
 * Build component README
 */
async function buildComponentReadme(uswdsName, blockName, blockDir) {
  const uswdsComponentName = uswdsName.replace('usa-', '');
  const uswdsUrl = `https://designsystem.digital.gov/components/${uswdsComponentName}/`;

  const readme = `# ${titleCase(blockName)} Block

This block implements the [USWDS ${titleCase(uswdsComponentName)} component](${uswdsUrl}).

## Usage

In your document, create a table with the class \`${blockName}\`:

\`\`\`
| ${blockName} |
|---|
| Content here |
\`\`\`

## Variants

${config.docs.includeUswdsLinks ? `
See the [USWDS documentation](${uswdsUrl}) for available variants and options.
` : ''}

## Accessibility

This component follows USWDS accessibility guidelines and is WCAG 2.1 AA compliant.

## Development

- **CSS**: Compiled from USWDS Sass (\`${uswdsName}\`)
- **JS**: ${await hasComponentJS(uswdsName) ? `Uses USWDS \`${uswdsName}\` module` : 'CSS only, no JavaScript required'}

## Related

- [USWDS ${titleCase(uswdsComponentName)}](${uswdsUrl})
- [USWDS Design Tokens](https://designsystem.digital.gov/design-tokens/)

---

*This file was auto-generated by \`build-uswds.js\`. Manual edits may be overwritten.*
`;

  const outputPath = path.join(blockDir, 'README.md');
  await fs.writeFile(outputPath, readme);

  log.verbose(`  README created â†’ ${outputPath}`);
}

/**
 * Check if component has JavaScript
 */
async function hasComponentJS(uswdsName) {
  const jsPath = path.join(
    config.uswds.packagesPath,
    uswdsName,
    'src',
    'index.js'
  );
  return fs.pathExists(jsPath);
}

/**
 * Compile Sass to CSS
 */
async function compileSass(sassContent, outputPath) {
  try {
    // Compile Sass
    const result = sass.compileString(sassContent, {
      loadPaths: config.sass.includePaths,
      style: config.sass.outputStyle,
      sourceMap: config.build.sourceMaps,
    });

    // Post-process with autoprefixer
    const processed = await postcss([
      autoprefixer(config.postcss.autoprefixer)
    ]).process(result.css, {
      from: undefined,
      to: outputPath,
    });

    // Write CSS file
    await fs.writeFile(outputPath, processed.css);

    // Write source map if enabled
    if (config.build.sourceMaps && result.sourceMap) {
      await fs.writeFile(`${outputPath}.map`, JSON.stringify(result.sourceMap));
    }

  } catch (error) {
    throw new Error(`Sass compilation failed: ${error.message}`);
  }
}

/**
 * Copy USWDS assets (fonts, icons, images)
 */
async function copyAssets() {
  log.info('Copying USWDS assets...');

  await copyFonts();
  await copyIcons();
  await copyImages();

  log.success('Assets copied');
}

/**
 * Copy USWDS fonts
 */
async function copyFonts() {
  log.verbose('  Copying fonts...');

  const uswdsFontsPath = path.join(config.uswds.packagePath, 'dist', 'fonts');
  const outputFontsPath = config.output.fonts;

  for (const family of config.assets.fonts.families) {
    const srcPath = path.join(uswdsFontsPath, family);
    const destPath = path.join(outputFontsPath, family);

    if (await fs.pathExists(srcPath)) {
      await fs.copy(srcPath, destPath, {
        filter: (src) => {
          // Only copy specified formats
          const ext = path.extname(src).slice(1);
          return !ext || config.assets.fonts.formats.includes(ext);
        },
      });
      log.verbose(`    Copied ${family}`);
    }
  }
}

/**
 * Copy USWDS icons
 */
async function copyIcons() {
  log.verbose('  Copying icons...');

  const uswdsImgPath = path.join(config.uswds.packagePath, 'dist', 'img');
  const outputIconsPath = config.output.icons;

  if (config.assets.icons.copyAll) {
    // Copy all icon directories
    for (const iconSet of config.assets.icons.sets) {
      const srcPath = path.join(uswdsImgPath, iconSet);
      const destPath = path.join(outputIconsPath, iconSet);

      if (await fs.pathExists(srcPath)) {
        await fs.copy(srcPath, destPath);
        log.verbose(`    Copied ${iconSet}`);
      }
    }

    // Copy sprite
    if (config.assets.icons.generateSprite) {
      const spriteSrc = path.join(uswdsImgPath, 'sprite.svg');
      const spriteDest = path.join(outputIconsPath, 'sprite.svg');

      if (await fs.pathExists(spriteSrc)) {
        await fs.copy(spriteSrc, spriteDest);
        log.verbose('    Copied sprite.svg');
      }
    }
  }
}

/**
 * Copy USWDS images
 */
async function copyImages() {
  if (!config.assets.images.copy) {
    return;
  }

  log.verbose('  Copying images...');

  const uswdsImgPath = path.join(config.uswds.packagePath, 'dist', 'img');
  const outputImagesPath = config.output.images;

  // Copy non-icon images
  const images = await fs.readdir(uswdsImgPath);

  for (const image of images) {
    const srcPath = path.join(uswdsImgPath, image);
    const stat = await fs.stat(srcPath);

    // Skip icon directories
    if (stat.isDirectory() && config.assets.icons.sets.includes(image)) {
      continue;
    }

    // Skip sprite
    if (image === 'sprite.svg') {
      continue;
    }

    const destPath = path.join(outputImagesPath, image);
    await fs.copy(srcPath, destPath);
    log.verbose(`    Copied ${image}`);
  }
}

/**
 * Generate documentation
 */
async function generateDocs() {
  log.info('Generating documentation...');

  // TODO: Generate comprehensive documentation
  // - Component inventory
  // - Usage examples
  // - Migration guide

  log.success('Documentation generated');
}

/**
 * Check bundle sizes
 */
async function checkBundleSizes() {
  log.info('Checking bundle sizes...');

  // Check core CSS
  const coreCssPath = path.join(config.output.styles, 'uswds-core.css');
  const coreSize = (await fs.stat(coreCssPath)).size;

  if (coreSize > config.testing.maxBundleSize.core) {
    log.warn(`Core CSS (${formatBytes(coreSize)}) exceeds recommended size (${formatBytes(config.testing.maxBundleSize.core)})`);
  } else {
    log.success(`Core CSS: ${formatBytes(coreSize)}`);
  }

  // Check block CSS sizes
  const blocks = await fs.readdir(config.output.blocks);

  for (const block of blocks) {
    const cssPath = path.join(config.output.blocks, block, `${block}.css`);

    if (await fs.pathExists(cssPath)) {
      const size = (await fs.stat(cssPath)).size;

      if (size > config.testing.maxBundleSize.block) {
        log.warn(`${block}.css (${formatBytes(size)}) exceeds recommended size (${formatBytes(config.testing.maxBundleSize.block)})`);
      }
    }
  }
}

/**
 * Utility: Convert to camelCase
 */
function camelCase(str) {
  return str
    .replace(/usa-/g, '')
    .replace(/-([a-z])/g, (g) => g[1].toUpperCase());
}

/**
 * Utility: Convert to Title Case
 */
function titleCase(str) {
  return str
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

/**
 * Utility: Format bytes to human readable
 */
function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
}

/**
 * Watch mode
 */
async function watch() {
  log.info('Watching for changes...');
  // TODO: Implement file watching
  // Watch USWDS source files and config
  // Rebuild on changes
}

// Run build
if (options.watch) {
  watch();
} else {
  build();
}
